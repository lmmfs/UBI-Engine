##############window################33
pub struct WinitWindow {
    window: winit::window::Window,
    surface: glutin::surface::Surface<glutin::surface::WindowSurface>,
    context: glutin::context::PossiblyCurrentContext,
    gl_display: glutin::display::Display,
    event_loop: winit::event_loop::EventLoop<()>, // will use run_return()
    event_buffer: Vec<winit::event::Event<'static, ()>>,
}

impl crate::window::Window for WinitWindow {
    fn create(window_data: WindowData) -> Result<Self, String> {
        let event_loop = EventLoop::new().map_err(|e| e.to_string())?;
        let window_builder = WindowBuilder::new()
            .with_title(window_data.name)
            .with_inner_size(PhysicalSize::new(window_data.width as u32, window_data.height as u32));

        let template = ConfigTemplateBuilder::new().with_depth_size(24).build();
        let display_builder = DisplayBuilder::new().with_window_builder(Some(window_builder));

        let (window, config) = display_builder
            .build(&event_loop, template, |configs| configs[0].clone())
            .map_err(|e| e.to_string())?;

        let window = window.ok_or("Window creation failed")?;
        let raw_window_handle = window.raw_window_handle();
        let gl_display = config.display();

        let context_attributes = ContextAttributesBuilder::new()
            .with_context_api(ContextApi::OpenGl(Some((3, 3))))
            .build(Some(raw_window_handle));

        let not_current_context = gl_display
            .create_context(&config, &context_attributes)
            .map_err(|e| format!("{:?}", e))?;

        let attrs = SurfaceAttributesBuilder::<WindowSurface>::new()
            .build(
                raw_window_handle,
                NonZeroU32::new(window_data.width as u32).unwrap(),
                NonZeroU32::new(window_data.height as u32).unwrap(),
            );

        let surface = gl_display
            .create_window_surface(&config, &attrs)
            .map_err(|e| format!("{:?}", e))?;

        let context = not_current_context
            .make_current(&surface)
            .map_err(|e| format!("{:?}", e))?;

        gl::load_with(|s| context.get_proc_address(s) as *const _);

        Ok(Self {
            window,
            surface,
            context,
            gl_display,
            event_loop,
            event_buffer: Vec::new(),
        })
    }

    fn poll_events(&mut self) -> Vec<Box<dyn crate::event::event::Event>> {
        let mut new_events = vec![];

        let mut event_collector = vec![];

        self.event_loop.run_return(|event, _, control_flow| {
            *control_flow = ControlFlow::Poll;
            event_collector.push(event.to_static().unwrap()); // requires nightly or workaround below
        });

        for event in event_collector.drain(..) {
            match event {
                Event::WindowEvent { event, .. } => match event {
                    WindowEvent::CloseRequested => {
                        new_events.push(Box::new(crate::event::WindowCloseEvent::new()));
                    }
                    WindowEvent::Resized(physical_size) => {
                        new_events.push(Box::new(crate::event::WindowResizeEvent::new(
                            physical_size.width as i32,
                            physical_size.height as i32,
                        )));
                    }
                    WindowEvent::KeyboardInput { input, .. } => {
                        if let Some(key) = input.virtual_keycode {
                            new_events.push(Box::new(crate::event::KeyPressedEvent::new(key)));
                        }
                    }
                    _ => {}
                },
                _ => {}
            }
        }

        new_events
    }

    fn get_size(&self) -> (u32, u32) {
        let size = self.window.inner_size();
        (size.width, size.height)
    }

    fn swap_buffers(&self) {
        self.surface.swap_buffers(&self.context).unwrap();
    }

    fn clear(&self) {
        unsafe {
            gl::ClearColor(0.1, 0.2, 0.3, 1.0);
            gl::Clear(gl::COLOR_BUFFER_BIT);
        }
    }

    fn resize(&self, width: i32, height: i32) {
        self.surface
            .resize(
                &self.context,
                NonZeroU32::new(width as u32).unwrap(),
                NonZeroU32::new(height as u32).unwrap(),
            )
            .unwrap();
    }
}

##############Application###################

loop {
    let events = window.poll_events();
    for event in events {
        dispatch(event); // like you're doing now
    }

    window.clear();
    update_logic();
    window.swap_buffers();
}
