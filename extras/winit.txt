// We use glutin-winit's DisplayBuilder to create an OpenGL context with a window.
// According to docs, DisplayBuilder initializes the OpenGL platform and creates a window&#8203;:contentReference[oaicite:0]{index=0},
// using winit for event loop management. 
// We also need a ConfigTemplateBuilder from glutin to pick a GL config.

use glutin_winit::DisplayBuilder;
use glutin::config::ConfigTemplateBuilder;
use glutin::prelude::*;
use glutin::surface::{SurfaceAttributesBuilder, WindowSurface, SwapInterval};
use glutin::context::{ContextAttributesBuilder, NotCurrentContext, PossiblyCurrentContext};
use raw_window_handle::HasRawWindowHandle;
use winit::event_loop::EventLoop;
use winit::window::WindowBuilder;
use std::num::NonZeroU32;

// Trait for window abstraction in the engine.
pub trait UBIWindow {
    fn create(event_loop: &EventLoop<()>, width: u32, height: u32, title: &str) -> Self;
    fn poll_events(&mut self) -> Vec<Box<dyn UBIEvent>>;
    fn swap_buffers(&self);
    fn resize(&self, width: u32, height: u32);
    fn clear(&self, color: [f32; 4]);
    fn get_size(&self) -> (u32, u32);
}

// Placeholder trait for events returned by poll_events.
pub trait UBIEvent {}

// A struct that encapsulates a window and OpenGL context using glutin and winit.
// It implements the UBIWindow trait for use in an engine.
pub struct WinitWindow {
    // The winit window handle
    pub window: winit::window::Window,
    // The OpenGL context; we will make it current before rendering
    pub gl_context: PossiblyCurrentContext,
    // The winit event loop (owned by the application, typically)
    pub event_loop: EventLoop<()>,
}

impl UBIWindow for WinitWindow {
    /// Creates a new window, GL context, and returns a WinitWindow instance.
    fn create(event_loop: &EventLoop<()>, width: u32, height: u32, title: &str) -> Self {
        // Prepare a window builder with desired size and title.
        let window_builder = WindowBuilder::new()
            .with_title(title)
            .with_inner_size(winit::dpi::PhysicalSize::new(width, height));

        // Config template: request a double-buffered OpenGL context.
        let config_template = ConfigTemplateBuilder::new()
            .with_double_buffer(Some(true))
            .with_depth_size(24);

        // DisplayBuilder from glutin-winit initializes the OpenGL display and window.
        // It will bootstrap glutin with winit to create the display and pick a config&#8203;:contentReference[oaicite:1]{index=1}&#8203;:contentReference[oaicite:2]{index=2}.
        let display_builder = DisplayBuilder::new()
            .with_window_builder(Some(window_builder));

        // Build the display and window surface. We pass in the event loop, template, and a config picker.
        let (window, gl_config) = display_builder
            .build(event_loop, config_template, |configs| {
                // Pick the first available config as example. Real code might filter for desired features.
                configs.next().unwrap()
            })
            .expect("Failed to create window and OpenGL configuration");

        // The Window may be None if no window is needed (e.g., headless), but here we passed Some(WindowBuilder).
        let window = window.expect("Window was not created");

        // Create a context builder to attach OpenGL context to the window.
        // We use ContextAttributesBuilder; this effectively builds the GL context for the window&#8203;:contentReference[oaicite:3]{index=3}.
        let context_attribs = ContextAttributesBuilder::new().build(Some(window.raw_window_handle()));
        let not_current_gl_context = gl_config
            .display()
            .create_context(&gl_config, &context_attribs)
            .expect("Failed to create GL context");
        // Make context current.
        let gl_context = not_current_gl_context.make_current().expect("Failed to make GL context current");

        // Optionally set swap interval (vsync) on the surface.
        gl_context.surface().set_swap_interval(SwapInterval::Wait(NonZeroU32::new(1).unwrap())).ok();

        WinitWindow {
            window,
            gl_context,
            event_loop: event_loop.clone(),
        }
    }

    /// Polls for window and input events, returning them as a list of UBIEvent trait objects.
    fn poll_events(&mut self) -> Vec<Box<dyn UBIEvent>> {
        let mut events: Vec<Box<dyn UBIEvent>> = Vec::new();
        // We'll use run_return to fetch any pending events. In a real engine, this could be integrated differently.
        self.event_loop.run_return(|event, _, control_flow| {
            match event {
                // Handle window close event.
                winit::event::Event::WindowEvent { event: winit::event::WindowEvent::CloseRequested, .. } => {
                    // In a full implementation, you might signal the app to exit.
                    // Here we just exit the loop.
                    *control_flow = winit::event_loop::ControlFlow::Exit;
                }
                // Handle resize event: update gl viewport.
                winit::event::Event::WindowEvent { event: winit::event::WindowEvent::Resized(physical_size), .. } => {
                    let size = (physical_size.width, physical_size.height);
                    self.resize(size.0, size.1);
                }
                _ => (),
            }
        });
        events
    }

    /// Swap the front and back buffers to present the rendered frame.
    fn swap_buffers(&self) {
        // Assuming the context is current, swap the buffers on the surface.
        // glutin's PossiblyCurrentContext has a swap_buffers method.
        self.gl_context.swap_buffers().unwrap();
    }

    /// Resize the OpenGL viewport and window.
    fn resize(&self, width: u32, height: u32) {
        self.window.set_inner_size(winit::dpi::PhysicalSize::new(width, height));
        // Also update viewport to the new size:
        unsafe { 
            gl::Viewport(0, 0, width as i32, height as i32);
        }
    }

    /// Clear the screen with the given color.
    fn clear(&self, color: [f32; 4]) {
        unsafe {
            gl::ClearColor(color[0], color[1], color[2], color[3]);
            gl::Clear(gl::COLOR_BUFFER_BIT);
        }
    }

    /// Get current size of the window.
    fn get_size(&self) -> (u32, u32) {
        let size = self.window.inner_size();
        (size.width, size.height)
    }
}

// Placeholder event structs implementing UBIEvent.
struct CloseWindowEvent;
impl UBIEvent for CloseWindowEvent {}

// The gl crate (e.g., gl::) is used here for issuing OpenGL commands in clear().
// Ensure you have loaded the OpenGL function pointers before calling these (e.g., via glow or gl).

